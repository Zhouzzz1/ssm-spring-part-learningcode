

## 1.bean的解释

在面向对象编程中，一个"实例对象"指的是一个类的具体实例化结果。当你创建一个类时，你定义了这个类的结构和行为，但是要使用这个类，你需要创建一个实际的对象。这个对象就是这个类的一个实例。

详细来说，让我们以一个例子来说明：

假设有一个类 `Car`，它有属性 `color` 和 `brand`，以及方法 `start()` 和 `drive()`。

```java
public class Car {
    private String color;
    private String brand;

    public Car(String color, String brand) {
        this.color = color;
        this.brand = brand;
    }

    public void start() {
        System.out.println("Car is starting...");
    }

    public void drive() {
        System.out.println("Car is driving...");
    }
}
```

现在，如果我们要使用这个 `Car` 类，我们需要实例化它，即创建一个 `Car` 类的对象：

```java
Car myCar = new Car("red", "Toyota");
```

在这里，`myCar` 就是 `Car` 类的一个实例对象。它具有 `color` 属性值为 "red"，`brand` 属性值为 "Toyota"，并且可以调用 `start()` 和 `drive()` 方法。

在Spring框架中，`@Bean` 注解用于告诉Spring容器如何创建和配置bean实例。当你在Spring应用程序上下文中声明一个bean时，Spring框架会根据你的配置创建这个类的一个实例对象，并且将它注入到需要使用这个bean的地方。这个实例对象就是所谓的"bean"。

## 2.**Spring中的单例与多例**

**1，什么是单例和多例**

[单例](https://so.csdn.net/so/search?q=单例&spm=1001.2101.3001.7020)：所有请求用同一个对象来处理。通过单例模式，可以保证系统中一个类只有一个实例。
多例：每个请求用一个新的对象来处理。

**2，Spring中的单例与多例**

spring ioc容器的bean都是默认单例的，即spring依赖注入Bean实例默认是单例的。

spring提供了5中scope，分别是singleton，prototype，request，session，global session，常用是前两种。


如果一个bean被声明为单例的时候，在处理多次请求的时候，在spring容器里只实例化出一个bean，后续的请求都公用这个对象，这个对象会保存在一个map里面。当有请求来的时候，会先从缓存（map）里查看有没有，有的话直接使用这个对象，没有的话才实例化一个新的对象，所以这是个单例的。但是对于原型（prototype）bean来说，当每次请求来的时候，会直接实例化新的bean，没有缓存以及缓存查询的过程。

**3.为什么用单例、多例**：
之所以用单例，是因为没必要每个请求都新建一个对象，这样子既浪费CPU又浪费内存；
之所以用多例，是为了防止并发问题；即一个请求改变了对象的状态，此时对象又处理另一个请求，而之前请求对对象状态的改变导致了对象对另一个请求做了错误的处理；
 用单例和多例的标准只有一个：
 当对象含有可改变的状态时（更精确的说就是在实际应用中该状态会改变），则多例，否则单例；

**4，单例的优势与劣势**
**优势：** 
由于不会创建新的对象，所以有以下几个性能上的优势：

减少新生成实例的消耗。新生成实例包括两个方面，第一，spring会通过反射或者cglib来生成bean实例，这都是耗性能的操作。第二，给对象分配内存也会涉及负责算法。
减少jvm垃圾回收。由于不会给每个请求都生成bean实例，所以回收的对象就少了。
可以快速获取到bean。因为单例获取bean操作，除了第一次生成之外，其余都是从缓存里获取的，所以很快。
**劣势：**
一个很大的劣势是它不能做到线程安全。由于所有请求都共享一个bean实例，那么如果这个bean是一个有状态的bean的话，在并发场景下就有可能出现问题。

**5，spring单例模式与线程安全：**
当多用户同时请求一个服务时，容器会给每一个请求分配一个线程，这时多个线程会并发执行该请求所对应的业务逻辑（成员方法），此时就要注意了，如果该处理逻辑中有对该单例状态的修改（体现为该单例的成员属性），则必须考虑线程同步问题（此时该状态就是一个临界资源（共享数据），如果多个线程同时操作（修改）这个临界资源就会诱发线程安全问题）。

线程安全：如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行的结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。或者说：一个类或者程序所提供的接口对于线程来说是原子操作，或者多线程之间的切换不会导致该接口的执行结果存在二义性，就是线程安全的。

线程安全问题都是由全局变量及静态变量引起的。
若每个线程中对全局变量，静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若多个线程同时执行写操作，一般都需要考虑线程同步，否则就可能影响线程安全。

常量始终是线程安全的，因为只存在读操作；
每次调用方法前都新建一个实例是线程安全的，因为不会访问共享的资源；
局部变量是线程安全的。因为每执行一个方法，都会在独立的空间创建局部变量，它不是共享资源。局部变量包括方法的参数变量和方法内的变量。
在关于spring单例与线程安全的很多文章中，会提到一个概念，即有状态bean和无状态bean。
无状态bean：无状态，就是一次操作，不能保存数据。无状态bean，就是没有实例变量的对象，不能保存数据，是不变类，在线程安全的。
有状态bean：有状态，就是有数据存储功能。有状态bean，就是有实例变量的对象，可以保存数据，是非线程安全的。

如何解决线程安全问题？
（1）使用线程同步机制：通过对象的锁机制保证同一时间只有一个线程访问变量。这时该变量是多个线程共享的，使用同步机制要求程序缜密地分析什么时候对变量进行读写，什么时候需要锁定某个对象，什么时候释放对象锁等繁杂问题，程序设计和编写难度相对较大。
（2）使用ThreadLocal：为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。

概括起来就是：对于多线程资源共享的问题，同步机制采用了“以时间换空间”的方式，而ThreadLocal采用了“以空间换时间”的方式。前者仅提供一份变量，让不同的线程排队访问，而后者为每一个线程都提供了一份变量，因此可以同时访问而互不影响。

**6，单例如何变多例**
Scope声明为prototype，即

@Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE)

